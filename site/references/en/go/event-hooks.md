# Event Hooks

The standard way to modify PocketBase is through **event hooks** in your Go code.

All hooks have 3 main methods:

- [**`Bind(handler)`**](https://pkg.go.dev/github.com/pocketbase/pocketbase/tools/hook#Hook.Bind) - adds a new handler to the specified event hook. A handler has 3 fields:
  - `Id` *(optional)* - the name of the handler (could be used as argument for `Unbind`)
  - `Priority` *(optional)* - the execution order of the handler (if empty fallbacks to the order of registration in the code).
  - `Func` *(required)* - the handler function.

- [**`BindFunc(func)`**](https://pkg.go.dev/github.com/pocketbase/pocketbase/tools/hook#Hook.BindFunc) - is similar to `Bind` but registers a new handler from just the provided function. <br> The registered handler is added with a default 0 priority and the id is autogenerated (the returned string value).

- [**`Trigger(event, oneOffHandlerFuncs...)`**](https://pkg.go.dev/github.com/pocketbase/pocketbase/tools/hook#Hook.Trigger) - triggers the event hook. <br> <em class="txt-hint">This method rarely has to be called manually by users.</em>

To remove an already registered hook handler, you can use the handler id and pass it to `Unbind(id)` or remove all handlers with `UnbindAll()` (*!including system handlers*).

::: info
All hook handler functions share the same `func(e T) error` signature and expect the user to call `e.Next()` if they want to proceed with the execution chain.

**If you need to access the app instance from inside a hook handler, prefer using the `e.App` field instead of reusing a parent scope app variable because the hook could be part of a DB transaction and can cause deadlock.**

Also avoid using global mutex locks inside a hook handler because it could be invoked recursively (e.g. cascade delete) and can cause deadlock.
:::

You can explore all available hooks below:

- [App hooks](#app-hooks)
- [Mailer hooks](#mailer-hooks)
- [Realtime hooks](#realtime-hooks)
- [Record model hooks](#record-model-hooks)
- [Collection model hooks](#collection-model-hooks)
- [Request hooks](#request-hooks)
- [Base model hooks](#base-model-hooks)

## App Hooks

### OnBootstrap

`OnBootstrap` hook is triggered when initializing the main application resources (db, app settings, etc).

::: warning
Note that attempting to access the database before the `e.Next()` call will result in an error.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnBootstrap().BindFunc(func(e *core.BootstrapEvent) error {
        if err := e.Next(); err != nil {
            return err
        }

        // e.App

        return nil
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnServe

`OnServe` hook is triggered when the app web server is started (after starting the TCP listener but before initializing the blocking serve task), allowing you to adjust its options and attach new routes or middlewares.

```go
package main

import (
    "log"
    "net/http"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/apis"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnServe().BindFunc(func(e *core.ServeEvent) error {
        // register new "GET /hello" route
        e.Router.GET("/hello", func(e *core.RequestEvent) error {
            return e.String(200, "Hello world!")
        }).Bind(apis.RequireAuth())

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnSettingsReload

`OnSettingsReload` hook is triggered every time when the `App.Settings()` is being replaced with a new state.

::: info
Calling `e.App.Settings()` after `e.Next()` returns the new state.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnSettingsReload().BindFunc(func(e *core.SettingsReloadEvent) error {
        if err := e.Next(); err != nil {
            return err
        }

        // e.App.Settings()

        return nil
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnBackupCreate

`OnBackupCreate` hook is triggered on each `App.CreateBackup` call.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnBackupCreate().BindFunc(func(e *core.BackupEvent) error {
        // e.App
        // e.Name    - the name of the backup to create
        // e.Exclude - list of pb_data dir entries to exclude from the backup

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnBackupRestore

`OnBackupRestore` hook is triggered before app backup restore (aka. on `App.RestoreBackup` call).

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnBackupRestore().BindFunc(func(e *core.BackupEvent) error {
        // e.App
        // e.Name    - the name of the backup to restore
        // e.Exclude - list of dir entries to exclude from the backup

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnTerminate

`OnTerminate` hook is triggered when the app is in the process of being terminated (ex. on `SIGTERM` signal).

::: warning
Note that the app could be terminated abruptly without awaiting the hook completion.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnTerminate().BindFunc(func(e *core.TerminateEvent) error {
        // e.App
        // e.IsRestart

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

## Mailer Hooks

### OnMailerSend

`OnMailerSend` hook is triggered every time when a new email is being sent using the `App.NewMailClient()` instance.

It allows intercepting the email message or to use a custom mailer client.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnMailerSend().BindFunc(func(e *core.MailerEvent) error {
        // e.App
        // e.Mailer
        // e.Message

        // ex. change the mail subject
        e.Message.Subject = "new subject"

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnMailerRecordAuthAlertSend

`OnMailerRecordAuthAlertSend` hook is triggered when sending a new device login auth alert email, allowing you to intercept and customize the email message that is being sent.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnMailerRecordAuthAlertSend().BindFunc(func(e *core.MailerRecordEvent) error {
        // e.App
        // e.Mailer
        // e.Message
        // e.Record
        // e.Meta["info"].(string)

        // ex. change the mail subject
        e.Message.Subject = "new subject"

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnMailerRecordPasswordResetSend

`OnMailerRecordPasswordResetSend` hook is triggered when sending a password reset email to an auth record, allowing you to intercept and customize the email message that is being sent.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnMailerRecordPasswordResetSend().BindFunc(func(e *core.MailerRecordEvent) error {
        // e.App
        // e.Mailer
        // e.Message
        // e.Record
        // e.Meta["token"].(string)

        // ex. change the mail subject
        e.Message.Subject = "new subject"

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnMailerRecordVerificationSend

`OnMailerRecordVerificationSend` hook is triggered when sending a verification email to an auth record, allowing you to intercept and customize the email message that is being sent.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnMailerRecordVerificationSend().BindFunc(func(e *core.MailerRecordEvent) error {
        // e.App
        // e.Mailer
        // e.Message
        // e.Record
        // e.Meta["token"].(string)

        // ex. change the mail subject
        e.Message.Subject = "new subject"

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnMailerRecordEmailChangeSend

`OnMailerRecordEmailChangeSend` hook is triggered when sending a confirmation new address email to an auth record, allowing you to intercept and customize the email message that is being sent.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnMailerRecordEmailChangeSend().BindFunc(func(e *core.MailerRecordEvent) error {
        // e.App
        // e.Mailer
        // e.Message
        // e.Record
        // e.Meta["token"].(string)
        // e.Meta["newEmail"].(string)

        // ex. change the mail subject
        e.Message.Subject = "new subject"

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnMailerRecordOTPSend

`OnMailerRecordOTPSend` hook is triggered when sending an OTP email to an auth record, allowing you to intercept and customize the email message that is being sent.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnMailerRecordOTPSend().BindFunc(func(e *core.MailerRecordEvent) error {
        // e.App
        // e.Mailer
        // e.Message
        // e.Record
        // e.Meta["otpId"].(string)
        // e.Meta["password"].(string)

        // ex. change the mail subject
        e.Message.Subject = "new subject"

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

## Realtime Hooks

### OnRealtimeConnectRequest

`OnRealtimeConnectRequest` hook is triggered when establishing the SSE client connection.

::: info
Any execution after `e.Next()` of a hook handler happens after the client disconnects.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnRealtimeConnectRequest().BindFunc(func(e *core.RealtimeConnectRequestEvent) error {
        // e.App
        // e.Client
        // e.IdleTimeout
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRealtimeSubscribeRequest

`OnRealtimeSubscribeRequest` hook is triggered when updating the client subscriptions, allowing you to further validate and modify the submitted change.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnRealtimeSubscribeRequest().BindFunc(func(e *core.RealtimeSubscribeRequestEvent) error {
        // e.App
        // e.Client
        // e.Subscriptions
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRealtimeMessageSend

`OnRealtimeMessageSend` hook is triggered when sending an SSE message to a client.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnRealtimeMessageSend().BindFunc(func(e *core.RealtimeMessageEvent) error {
        // e.App
        // e.Client
        // e.Message
        // and all original connect RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

## Record Model Hooks

::: info
These are lower level Record model hooks and could be triggered from anywhere (custom console command, scheduled cron job, when calling `e.Save(record)`, etc.) and therefore they have no access to the request context!

If you want to intercept the builtin Web APIs and to access their request body, query parameters, headers or the request auth state, then please use the designated [Record `*Request` hooks](#record-crud-request-hooks).
:::

### OnRecordEnrich

`OnRecordEnrich` hook is triggered every time when a record is enriched - as part of the builtin Record responses, during realtime message serialization, or when `apis.EnrichRecord` is invoked.

It could be used for example to redact/hide or add computed temporary Record model props only for the specific request info.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnRecordEnrich("posts").BindFunc(func(e *core.RecordEnrichEvent) error {
        // hide one or more fields
        e.Record.Hide("role")

        // add new custom field for registered users
        if e.RequestInfo.Auth != nil && e.RequestInfo.Auth.Collection().Name == "users" {
            e.Record.WithCustomData(true) // for security requires explicitly allowing it
            e.Record.Set("computedScore", e.Record.GetInt("score") * e.RequestInfo.Auth.GetInt("base"))
        }

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordValidate

`OnRecordValidate` is a Record proxy model hook of `OnModelValidate`.

`OnRecordValidate` is triggered every time when a Record is being validated, e.g. triggered by `App.Validate()` or `App.Save()`.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordValidate().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordValidate("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordCreate

`OnRecordCreate` is a Record proxy model hook of `OnModelCreate`.

`OnRecordCreate` is triggered every time when a new Record is being created, e.g. triggered by `App.Save()`.

Operations BEFORE the `e.Next()` execute before the Record validation and the INSERT DB statement.

Operations AFTER the `e.Next()` execute after the Record validation and the INSERT DB statement.

::: warning
Note that successful execution doesn't guarantee that the Record is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnRecordAfterCreateSuccess` or `OnRecordAfterCreateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordCreate().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordCreate("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordCreateExecute

`OnRecordCreateExecute` is a Record proxy model hook of `OnModelCreateExecute`.

`OnRecordCreateExecute` is triggered after successful Record validation and right before the model INSERT DB statement execution.

Usually it is triggered as part of the `App.Save()` in the following firing order:

`OnRecordCreate`  
&nbsp;-> `OnRecordValidate` (skipped with `App.SaveNoValidate()`)  
&nbsp;-> `OnRecordCreateExecute`

::: warning
Note that successful execution doesn't guarantee that the Record is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnRecordAfterCreateSuccess` or `OnRecordAfterCreateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordCreateExecute().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordCreateExecute("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordAfterCreateSuccess

`OnRecordAfterCreateSuccess` is a Record proxy model hook of `OnModelAfterCreateSuccess`.

`OnRecordAfterCreateSuccess` is triggered after each successful Record DB create persistence.

::: warning
Note that when a Record is persisted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordAfterCreateSuccess().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordAfterCreateSuccess("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordAfterCreateError

`OnRecordAfterCreateError` is a Record proxy model hook of `OnModelAfterCreateError`.

`OnRecordAfterCreateError` is triggered after each failed Record DB create persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:
- **immediate** on `App.Save()` failure
- **delayed** on transaction rollback
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordAfterCreateError().BindFunc(func(e *core.RecordErrorEvent) error {
        // e.App
        // e.Record
        // e.Error

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordAfterCreateError("users", "articles").BindFunc(func(e *core.RecordErrorEvent) error {
        // e.App
        // e.Record
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordUpdate

`OnRecordUpdate` is a Record proxy model hook of `OnModelUpdate`.

`OnRecordUpdate` is triggered every time when a new Record is being updated, e.g. triggered by `App.Save()`.

Operations BEFORE the `e.Next()` execute before the Record validation and the UPDATE DB statement.

Operations AFTER the `e.Next()` execute after the Record validation and the UPDATE DB statement.

::: warning
Note that successful execution doesn't guarantee that the Record is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnRecordAfterUpdateSuccess` or `OnRecordAfterUpdateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordUpdate().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordUpdate("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordUpdateExecute

`OnRecordUpdateExecute` is a Record proxy model hook of `OnModelUpdateExecute`.

`OnRecordUpdateExecute` is triggered after successful Record validation and right before the model UPDATE DB statement execution.

Usually it is triggered as part of the `App.Save()` in the following firing order:

`OnRecordUpdate`  
&nbsp;-> `OnRecordValidate` (skipped with `App.SaveNoValidate()`)  
&nbsp;-> `OnRecordUpdateExecute`

::: warning
Note that successful execution doesn't guarantee that the Record is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnRecordAfterUpdateSuccess` or `OnRecordAfterUpdateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordUpdateExecute().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordUpdateExecute("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordAfterUpdateSuccess

`OnRecordAfterUpdateSuccess` is a Record proxy model hook of `OnModelAfterUpdateSuccess`.

`OnRecordAfterUpdateSuccess` is triggered after each successful Record DB update persistence.

::: warning
Note that when a Record is persisted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordAfterUpdateSuccess().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordAfterUpdateSuccess("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordAfterUpdateError

`OnRecordAfterUpdateError` is a Record proxy model hook of `OnModelAfterUpdateError`.

`OnRecordAfterUpdateError` is triggered after each failed Record DB update persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:
- **immediate** on `App.Save()` failure
- **delayed** on transaction rollback
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordAfterUpdateError().BindFunc(func(e *core.RecordErrorEvent) error {
        // e.App
        // e.Record
        // e.Error

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordAfterUpdateError("users", "articles").BindFunc(func(e *core.RecordErrorEvent) error {
        // e.App
        // e.Record
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordDelete

`OnRecordDelete` is a Record proxy model hook of `OnModelDelete`.

`OnRecordDelete` is triggered every time when a new Record is being deleted, e.g. triggered by `App.Delete()`.

Operations BEFORE the `e.Next()` execute before the Record validation and the UPDATE DB statement.

Operations AFTER the `e.Next()` execute after the Record validation and the UPDATE DB statement.

::: warning
Note that successful execution doesn't guarantee that the Record is deleted from the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted deleted events, you can bind to `OnRecordAfterDeleteSuccess` or `OnRecordAfterDeleteError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordDelete().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordDelete("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordDeleteExecute

`OnRecordDeleteExecute` is a Record proxy model hook of `OnModelDeleteExecute`.

`OnRecordDeleteExecute` is triggered after the internal delete checks and right before the model DELETE DB statement execution.

Usually it is triggered as part of the `App.Delete()` in the following firing order:

`OnRecordDelete`  
&nbsp;-> internal delete checks  
&nbsp;-> `OnRecordDeleteExecute`

::: warning
Note that successful execution doesn't guarantee that the Record is deleted from the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted deleted events, you can bind to `OnRecordAfterDeleteSuccess` or `OnRecordAfterDeleteError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordDeleteExecute().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordDeleteExecute("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordAfterDeleteSuccess

`OnRecordAfterDeleteSuccess` is a Record proxy model hook of `OnModelAfterDeleteSuccess`.

`OnRecordAfterDeleteSuccess` is triggered after each successful Record DB delete persistence.

::: warning
Note that when a Record is deleted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordAfterDeleteSuccess().BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordAfterDeleteSuccess("users", "articles").BindFunc(func(e *core.RecordEvent) error {
        // e.App
        // e.Record

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnRecordAfterDeleteError

`OnRecordAfterDeleteError` is a Record proxy model hook of `OnModelAfterDeleteError`.

`OnRecordAfterDeleteError` is triggered after each failed Record DB delete persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:
- **immediate** on `App.Delete()` failure
- **delayed** on transaction rollback
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every record
    app.OnRecordAfterDeleteError().BindFunc(func(e *core.RecordErrorEvent) error {
        // e.App
        // e.Record
        // e.Error

        return e.Next()
    })

    // fires only for "users" and "articles" records
    app.OnRecordAfterDeleteError("users", "articles").BindFunc(func(e *core.RecordErrorEvent) error {
        // e.App
        // e.Record
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

## Collection Model Hooks

::: info
These are lower level Collection model hooks and could be triggered from anywhere (custom console command, scheduled cron job, when calling `e.Save(collection)`, etc.) and therefore they have no access to the request context!

If you want to intercept the builtin Web APIs and to access their request body, query parameters, headers or the request auth state, then please use the designated [Collection `*Request` hooks](#oncollectionslistrequest).
:::

### OnCollectionValidate

`OnCollectionValidate` is a Collection proxy model hook of `OnModelValidate`.

`OnCollectionValidate` is triggered every time when a Collection is being validated, e.g. triggered by `App.Validate()` or `App.Save()`.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionValidate().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionCreate

`OnCollectionCreate` is a Collection proxy model hook of `OnModelCreate`.

`OnCollectionCreate` is triggered every time when a new Collection is being created, e.g. triggered by `App.Save()`.

Operations BEFORE the `e.Next()` execute before the Collection validation and the INSERT DB statement.

Operations AFTER the `e.Next()` execute after the Collection validation and the INSERT DB statement.

::: warning
Note that successful execution doesn't guarantee that the Collection is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnCollectionAfterCreateSuccess` or `OnCollectionAfterCreateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionCreate().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionCreateExecute

`OnCollectionCreateExecute` is a Collection proxy model hook of `OnModelCreateExecute`.

`OnCollectionCreateExecute` is triggered after successful Collection validation and right before the model INSERT DB statement execution.

Usually it is triggered as part of the `App.Save()` in the following firing order:

`OnCollectionCreate`  
&nbsp;-> `OnCollectionValidate` (skipped with `App.SaveNoValidate()`)  
&nbsp;-> `OnCollectionCreateExecute`

::: warning
Note that successful execution doesn't guarantee that the Collection is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnCollectionAfterCreateSuccess` or `OnCollectionAfterCreateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionCreateExecute().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionAfterCreateSuccess

`OnCollectionAfterCreateSuccess` is a Collection proxy model hook of `OnModelAfterCreateSuccess`.

`OnCollectionAfterCreateSuccess` is triggered after each successful Collection DB create persistence.

::: warning
Note that when a Collection is persisted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionAfterCreateSuccess().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionAfterCreateError

`OnCollectionAfterCreateError` is a Collection proxy model hook of `OnModelAfterCreateError`.

`OnCollectionAfterCreateError` is triggered after each failed Collection DB create persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:

- **immediate** on `App.Save()` failure
- **delayed** on transaction rollback
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionAfterCreateError().BindFunc(func(e *core.CollectionErrorEvent) error {
        // e.App
        // e.Collection
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionUpdate

`OnCollectionUpdate` is a Collection proxy model hook of `OnModelUpdate`.

`OnCollectionUpdate` is triggered every time when a new Collection is being updated, e.g. triggered by `App.Save()`.

Operations BEFORE the `e.Next()` execute before the Collection validation and the UPDATE DB statement.

Operations AFTER the `e.Next()` execute after the Collection validation and the UPDATE DB statement.

::: warning
Note that successful execution doesn't guarantee that the Collection is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnCollectionAfterUpdateSuccess` or `OnCollectionAfterUpdateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionUpdate().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionUpdateExecute

`OnCollectionUpdateExecute` is a Collection proxy model hook of `OnModelUpdateExecute`.

`OnCollectionUpdateExecute` is triggered after successful Collection validation and right before the model UPDATE DB statement execution.

Usually it is triggered as part of the `App.Save()` in the following firing order:

`OnCollectionUpdate`  
&nbsp;-> `OnCollectionValidate` (skipped with `App.SaveNoValidate()`)  
&nbsp;-> `OnCollectionUpdateExecute`

::: warning
Note that successful execution doesn't guarantee that the Collection is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnCollectionAfterUpdateSuccess` or `OnCollectionAfterUpdateError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionUpdateExecute().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionAfterUpdateSuccess

`OnCollectionAfterUpdateSuccess` is a Collection proxy model hook of `OnModelAfterUpdateSuccess`.

`OnCollectionAfterUpdateSuccess` is triggered after each successful Collection DB update persistence.

::: warning
Note that when a Collection is persisted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionAfterUpdateSuccess().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionAfterUpdateError

`OnCollectionAfterUpdateError` is a Collection proxy model hook of `OnModelAfterUpdateError`.

`OnCollectionAfterUpdateError` is triggered after each failed Collection DB update persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:

- **immediate** on `App.Save()` failure
- **delayed** on transaction rollback
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionAfterUpdateError().BindFunc(func(e *core.CollectionErrorEvent) error {
        // e.App
        // e.Collection
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionDelete

`OnCollectionDelete` is a Collection proxy model hook of `OnModelDelete`.

`OnCollectionDelete` is triggered every time when a new Collection is being deleted, e.g. triggered by `App.Delete()`.

Operations BEFORE the `e.Next()` execute before the Collection validation and the UPDATE DB statement.

Operations AFTER the `e.Next()` execute after the Collection validation and the UPDATE DB statement.

::: warning
Note that successful execution doesn't guarantee that the Collection is deleted from the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted deleted events, you can bind to `OnCollectionAfterDeleteSuccess` or `OnCollectionAfterDeleteError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionDelete().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionDeleteExecute

`OnCollectionDeleteExecute` is a Collection proxy model hook of `OnModelDeleteExecute`.

`OnCollectionDeleteExecute` is triggered after the internal delete checks and right before the Collection DELETE DB statement execution.

Usually it is triggered as part of the `App.Delete()` in the following firing order:

`OnCollectionDelete`  
&nbsp;-> internal delete checks  
&nbsp;-> `OnCollectionDeleteExecute`

::: warning
Note that successful execution doesn't guarantee that the Collection is deleted from the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted deleted events, you can bind to `OnCollectionAfterDeleteSuccess` or `OnCollectionAfterDeleteError` hooks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionDeleteExecute().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionAfterDeleteSuccess

`OnCollectionAfterDeleteSuccess` is a Collection proxy model hook of `OnModelAfterDeleteSuccess`.

`OnCollectionAfterDeleteSuccess` is triggered after each successful Collection DB delete persistence.

::: warning
Note that when a Collection is deleted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionAfterDeleteSuccess().BindFunc(func(e *core.CollectionEvent) error {
        // e.App
        // e.Collection

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnCollectionAfterDeleteError

`OnCollectionAfterDeleteError` is a Collection proxy model hook of `OnModelAfterDeleteError`.

`OnCollectionAfterDeleteError` is triggered after each failed Collection DB delete persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:

- **immediate** on `App.Delete()` failure
- **delayed** on transaction rollback
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionAfterDeleteError().BindFunc(func(e *core.CollectionErrorEvent) error {
        // e.App
        // e.Collection
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

## Request Hooks

::: info
The request hooks are triggered only when the corresponding API request endpoint is accessed.
:::

### Record CRUD Request Hooks

#### OnRecordsListRequest

`OnRecordsListRequest` hook is triggered on each API Records list request.
Could be used to validate or modify the response before returning it to the client.

::: warning
Note that if you want to hide existing or add new computed Record fields prefer using the [`OnRecordEnrich`](#onrecordenrich) hook because it is less error-prone and it is triggered by all builtin Record responses (including when sending realtime Record events).
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnRecordsListRequest().BindFunc(func(e *core.RecordsListRequestEvent) error {
        // e.App
        // e.Collection
        // e.Records
        // e.Result
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "articles" collections
    app.OnRecordsListRequest("users", "articles").BindFunc(func(e *core.RecordsListRequestEvent) error {
        // e.App
        // e.Collection
        // e.Records
        // e.Result
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordViewRequest

`OnRecordViewRequest` hook is triggered on each API Record view request.
Could be used to validate or modify the response before returning it to the client.

::: warning
Note that if you want to hide existing or add new computed Record fields prefer using the [`OnRecordEnrich`](#onrecordenrich) hook because it is less error-prone and it is triggered by all builtin Record responses (including when sending realtime Record events).
:::

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnRecordViewRequest().BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "articles" collections
    app.OnRecordViewRequest("users", "articles").BindFunc(func(e *core.RecordRequestEvent) error {
        log.Println(e.HttpContext)
        log.Println(e.Record)
        return nil
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordCreateRequest

`OnRecordCreateRequest` hook is triggered on each API Record create request.
<br>
Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnRecordCreateRequest().BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "articles" collections
    app.OnRecordCreateRequest("users", "articles").BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordUpdateRequest

`OnRecordUpdateRequest` hook is triggered on each API Record update request.
<br>
Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnRecordUpdateRequest().BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "articles" collections
    app.OnRecordUpdateRequest("users", "articles").BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordDeleteRequest

`OnRecordDeleteRequest` hook is triggered on each API Record delete request.
<br>
Could be used to additionally validate the request data or implement completely different delete behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnRecordDeleteRequest().BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "articles" collections
    app.OnRecordDeleteRequest("users", "articles").BindFunc(func(e *core.RecordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### Record Auth Request Hooks

#### OnRecordAuthRequest

`OnRecordAuthRequest` hook is triggered on each successful API record authentication request (sign-in, token refresh, etc.). Could be used to additionally validate or modify the authenticated record data and token.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordAuthRequest().BindFunc(func(e *core.RecordAuthRequestEvent) error {
        // e.App
        // e.Record
        // e.Token
        // e.Meta
        // e.AuthMethod
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordAuthRequest("users", "managers").BindFunc(func(e *core.RecordAuthRequestEvent) error {
        // e.App
        // e.Record
        // e.Token
        // e.Meta
        // e.AuthMethod
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordAuthRefreshRequest

`OnRecordAuthRefreshRequest` hook is triggered on each Record auth refresh API request (right before generating a new auth token).

Could be used to additionally validate the request data or implement completely different auth refresh behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordAuthRefreshRequest().BindFunc(func(e *core.RecordAuthWithOAuth2RequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordAuthRefreshRequest("users", "managers").BindFunc(func(e *core.RecordAuthWithOAuth2RequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordAuthWithPasswordRequest

`OnRecordAuthWithPasswordRequest` hook is triggered on each Record auth with password API request.

**`e.Record` could be `nil` if no matching identity is found, allowing you to manually locate a different Record model (by reassigning `e.Record`).**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordAuthWithPasswordRequest().BindFunc(func(e *core.RecordAuthWithPasswordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record (could be nil)
        // e.Identity
        // e.IdentityField
        // e.Password
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordAuthWithPasswordRequest("users", "managers").BindFunc(func(e *core.RecordAuthWithPasswordRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record (could be nil)
        // e.Identity
        // e.IdentityField
        // e.Password
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordAuthWithOAuth2Request

`OnRecordAuthWithOAuth2Request` hook is triggered on each Record OAuth2 sign-in/sign-up API request (after token exchange and before external provider linking).

If `e.Record` is not set, then the OAuth2 request will try to create a new auth record.
<br>
To assign or link a different existing record model you can change the `e.Record` field.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordAuthWithOAuth2Request().BindFunc(func(e *core.RecordAuthWithOAuth2RequestEvent) error {
        // e.App
        // e.Collection
        // e.ProviderName
        // e.ProviderClient
        // e.Record (could be nil)
        // e.OAuth2User
        // e.CreateData
        // e.IsNewRecord
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordAuthWithOAuth2Request("users", "managers").BindFunc(func(e *core.RecordAuthWithOAuth2RequestEvent) error {
        // e.App
        // e.Collection
        // e.ProviderName
        // e.ProviderClient
        // e.Record (could be nil)
        // e.OAuth2User
        // e.CreateData
        // e.IsNewRecord
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordRequestPasswordResetRequest

`OnRecordRequestPasswordResetRequest` hook is triggered on each Record request password reset API request.

Could be used to additionally validate the request data or implement completely different password reset behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordRequestPasswordResetRequest().BindFunc(func(e *core.RecordRequestPasswordResetRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordRequestPasswordResetRequest("users", "managers").BindFunc(func(e *core.RecordRequestPasswordResetRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordConfirmPasswordResetRequest

`OnRecordConfirmPasswordResetRequest` hook is triggered on each Record confirm password reset API request.

Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordConfirmPasswordResetRequest().BindFunc(func(e *core.RecordConfirmPasswordResetRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordConfirmPasswordResetRequest("users", "managers").BindFunc(func(e *core.RecordConfirmPasswordResetRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordRequestVerificationRequest

`OnRecordRequestVerificationRequest` hook is triggered on each Record request verification API request.

Could be used to additionally validate the request data or implement completely different verification behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordRequestVerificationRequest().BindFunc(func(e *core.RecordRequestVerificationRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordRequestVerificationRequest("users", "managers").BindFunc(func(e *core.RecordRequestVerificationRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordConfirmVerificationRequest

`OnRecordConfirmVerificationRequest` hook is triggered on each Record confirm verification API request.

Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordConfirmVerificationRequest().BindFunc(func(e *core.RecordConfirmVerificationRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordConfirmVerificationRequest("users", "managers").BindFunc(func(e *core.RecordConfirmVerificationRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordRequestEmailChangeRequest

`OnRecordRequestEmailChangeRequest` hook is triggered on each Record request email change API request.

Could be used to additionally validate the request data or implement completely different email change behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordRequestEmailChangeRequest().BindFunc(func(e *core.RecordRequestEmailChangeRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.NewEmail
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordRequestEmailChangeRequest("users", "managers").BindFunc(func(e *core.RecordRequestEmailChangeRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.NewEmail
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordConfirmEmailChangeRequest

`OnRecordConfirmEmailChangeRequest` hook is triggered on each Record confirm email change API request.

Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordConfirmEmailChangeRequest().BindFunc(func(e *core.RecordConfirmEmailChangeRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordConfirmEmailChangeRequest("users", "managers").BindFunc(func(e *core.RecordConfirmEmailChangeRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordRequestOTPRequest

`OnRecordRequestOTPRequest` hook is triggered on each Record request OTP API request.

**`e.Record` could be `nil` if no user with the requested email is found, allowing you to manually create a new Record or locate a different Record model (by reassigning `e.Record`).**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordRequestOTPRequest().BindFunc(func(e *core.RecordCreateOTPRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record (could be nil)
        // e.Password
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordRequestOTPRequest("users", "managers").BindFunc(func(e *core.RecordCreateOTPRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record (could be nil)
        // e.Password
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnRecordAuthWithOTPRequest

`OnRecordAuthWithOTPRequest` hook is triggered on each Record OTP auth API request.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every auth collection
    app.OnRecordAuthWithOTPRequest().BindFunc(func(e *core.RecordAuthWithOTPRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.OTP
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" auth collections
    app.OnRecordAuthWithOTPRequest("users", "managers").BindFunc(func(e *core.RecordAuthWithOTPRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.OTP
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### Batch request hooks

#### OnBatchRequest

`OnBatchRequest` hook is triggered on each API batch request.

Could be used to additionally validate or modify the submitted batch requests.

This hook will also fire the corresponding `OnRecordCreateRequest`, `OnRecordUpdateRequest`, `OnRecordDeleteRequest` hooks, where `e.App` is the batch transactional app.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnBatchRequest().BindFunc(func(e *core.BatchRequestEvent) error {
        // e.App
        // e.Batch
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnFileDownloadRequest

`OnFileDownloadRequest` hook is triggered before each API File download request.

Could be used to validate or modify the file response before returning it to the client.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnFileDownloadRequest().BindFunc(func(e *core.FileDownloadRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.FileField
        // e.ServedPath
        // e.ServedName
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "articles" collections
    app.OnFileDownloadRequest("users", "articles").BindFunc(func(e *core.FileDownloadRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.FileField
        // e.ServedPath
        // e.ServedName
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnFileTokenRequest

`OnFileTokenRequest` hook is triggered on each auth file token API request.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every collection
    app.OnFileTokenRequest().BindFunc(func(e *core.FileTokenRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.Token
        // and all RequestEvent fields...

        return e.Next()
    })

    // fires only for "users" and "managers" collections
    app.OnFileTokenRequest("users", "managers").BindFunc(func(e *core.FileTokenRequestEvent) error {
        // e.App
        // e.Collection
        // e.Record
        // e.Token
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### Collection Request Hooks

#### OnCollectionsListRequest

`OnCollectionsListRequest` hook is triggered on each API Collections list request.

Could be used to validate or modify the response before returning it to the client.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionsListRequest().BindFunc(func(e *core.CollectionsListRequestEvent) error {
        // e.App
        // e.Collections
        // e.Result
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnCollectionViewRequest

`OnCollectionViewRequest` hook is triggered on each API Collection view request.

Could be used to validate or modify the response before returning it to the client.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionViewRequest().BindFunc(func(e *core.CollectionRequestEvent) error {
        // e.App
        // e.Collection
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnCollectionCreateRequest

`OnCollectionCreateRequest` hook is triggered on each API Collection create request.

Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionCreateRequest().BindFunc(func(e *core.CollectionRequestEvent) error {
        // e.App
        // e.Collection
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnCollectionUpdateRequest

`OnCollectionUpdateRequest` hook is triggered on each API Collection update request.

Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionUpdateRequest().BindFunc(func(e *core.CollectionRequestEvent) error {
        // e.App
        // e.Collection
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnCollectionDeleteRequest

`OnCollectionDeleteRequest` hook is triggered on each API Collection delete request.

Could be used to additionally validate the request data or implement completely different delete behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionDeleteRequest().BindFunc(func(e *core.CollectionRequestEvent) error {
        // e.App
        // e.Collection
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnCollectionsImportRequest

`OnCollectionsImportRequest` hook is triggered on each API collections import request.

Could be used to additionally validate the imported collections or to implement completely different import behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnCollectionsImportRequest().BindFunc(func(e *core.CollectionsImportRequestEvent) error {
        // e.App
        // e.Collections
        // e.CollectionsData
        // e.DeleteMissing
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### Settings Request Hooks

#### OnSettingsListRequest

`OnSettingsListRequest` hook is triggered on each API Settings list request.

Could be used to validate or modify the response before returning it to the client.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnSettingsListRequest().BindFunc(func(e *core.SettingsListRequestEvent) error {
        // e.App
        // e.Settings
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

#### OnSettingsUpdateRequest

`OnSettingsUpdateRequest` hook is triggered on each API Settings update request.

Could be used to additionally validate the request data or implement completely different persistence behavior.

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    app.OnSettingsUpdateRequest().BindFunc(func(e *core.SettingsUpdateRequestEvent) error {
        // e.App
        // e.OldSettings
        // e.NewSettings
        // and all RequestEvent fields...

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

## Base Model Hooks

::: info
Generic hooks triggered for all PocketBase structs that implements the Model DB interface - Record, Collection, Log, etc.

For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the `OnRecord*` and `OnCollection*` proxy hooks.
:::

### OnModelValidate

`OnModelValidate` is called every time when a Model is being validated, e.g. triggered by `App.Validate()` or `App.Save()`.

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelValidate().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelValidate("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelCreate

`OnModelCreate` hook is triggered every time when a new Model is being created, e.g. triggered by `App.Save()`.

Operations BEFORE the `e.Next()` execute before the Model validation and the INSERT DB statement.

Operations AFTER the `e.Next()` execute after the Model validation and the INSERT DB statement.

::: warning
Note that successful execution doesn't guarantee that the Model is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnModelAfterCreateSuccess` or `OnModelAfterCreateError` hooks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelCreate().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelCreate("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelCreateExecute

`OnModelCreateExecute` hook is triggered after successful Model validation and right before the model INSERT DB statement execution.

Usually it is triggered as part of the `App.Save()` in the following firing order:

`OnModelCreate`  
&nbsp;-> `OnModelValidate` (skipped with `App.SaveNoValidate()`)  
&nbsp;-> `OnModelCreateExecute`

::: warning
Note that successful execution doesn't guarantee that the Model is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnModelAfterCreateSuccess` or `OnModelAfterCreateError` hooks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelCreateExecute().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelCreateExecute("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelAfterCreateSuccess

`OnModelAfterCreateSuccess` hook is triggered after each successful Model DB create persistence.

::: warning
Note that when a Model is persisted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelAfterCreateSuccess().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelAfterCreateSuccess("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelAfterCreateError

`OnModelAfterCreateError` hook is triggered after each failed Model DB create persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:

- **immediate** on `App.Save()` failure
- **delayed** on transaction rollback
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelAfterCreateError().BindFunc(func(e *core.ModelErrorEvent) error {
        // e.App
        // e.Model
        // e.Error

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelAfterCreateError("users", "articles").BindFunc(func(e *core.ModelErrorEvent) error {
        // e.App
        // e.Model
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelUpdate

`OnModelUpdate` hook is triggered every time when a new Model is being updated, e.g. triggered by `App.Save()`.

Operations BEFORE the `e.Next()` execute before the Model validation and the UPDATE DB statement.

Operations AFTER the `e.Next()` execute after the Model validation and the UPDATE DB statement.

::: warning
Note that successful execution doesn't guarantee that the Model is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnModelAfterUpdateSuccess` or `OnModelAfterUpdateError` hooks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelUpdate().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelUpdate("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelUpdateExecute

`OnModelUpdateExecute` hook is triggered after successful Model validation and right before the model UPDATE DB statement execution.

Usually it is triggered as part of the `App.Save()` in the following firing order:

`OnModelUpdate`  
&nbsp;-> `OnModelValidate` (skipped with `App.SaveNoValidate()`)  
&nbsp;-> `OnModelUpdateExecute`

::: warning
Note that successful execution doesn't guarantee that the Model is persisted in the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnModelAfterUpdateSuccess` or `OnModelAfterUpdateError` hooks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelUpdateExecute().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelUpdateExecute("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelAfterUpdateSuccess

`OnModelAfterUpdateSuccess` hook is triggered after each successful Model DB update persistence.

::: warning
Note that when a Model is persisted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelAfterUpdateSuccess().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelAfterUpdateSuccess("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelAfterUpdateError

`OnModelAfterUpdateError` hook is triggered after each failed Model DB update persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:

- **immediate** on `App.Save()` failure
- **delayed** on transaction rollback
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelAfterUpdateError().BindFunc(func(e *core.ModelErrorEvent) error {
        // e.App
        // e.Model
        // e.Error

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelAfterUpdateError("users", "articles").BindFunc(func(e *core.ModelErrorEvent) error {
        // e.App
        // e.Model
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelDelete

`OnModelDelete` hook is triggered every time when a new Model is being deleted, e.g. triggered by `App.Delete()`.

Operations BEFORE the `e.Next()` execute before the Model validation and the UPDATE DB statement.

Operations AFTER the `e.Next()` execute after the Model validation and the UPDATE DB statement.

::: warning
Note that successful execution doesn't guarantee that the Model is deleted from the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted deleted events, you can bind to `OnModelAfterDeleteSuccess` or `OnModelAfterDeleteError` hooks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelDelete().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelDelete("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelDeleteExecute

`OnModelDeleteExecute` hook is triggered after the internal delete checks and right before the model DELETE DB statement execution.

Usually it is triggered as part of the `App.Delete()` in the following firing order:

`OnModelDelete`  
&nbsp;-> internal delete checks  
&nbsp;-> `OnModelDeleteExecute`

::: warning
Note that successful execution doesn't guarantee that the Model is deleted from the database since its wrapping transaction may not have been committed yet. If you want to listen to only the actual persisted events, you can bind to `OnModelAfterDeleteSuccess` or `OnModelAfterDeleteError` hooks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelDeleteExecute().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelDeleteExecute("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelAfterDeleteSuccess

`OnModelAfterDeleteSuccess` hook is triggered after each successful Model DB delete persistence.

::: warning
Note that when a Model is deleted as part of a transaction, this hook is delayed and executed only AFTER the transaction has been committed. This hook is NOT triggered in case the transaction fails/rollbacks.
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelAfterDeleteSuccess().BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelAfterDeleteSuccess("users", "articles").BindFunc(func(e *core.ModelEvent) error {
        // e.App
        // e.Model

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

### OnModelAfterDeleteError

`OnModelAfterDeleteError` hook is triggered after each failed Model DB delete persistence.

::: warning
Note that the execution of this hook is either immediate or delayed depending on the error:

- **immediate** on `App.Delete()` failure
- **delayed** on transaction rollback
:::

**For convenience, if you want to listen to only the Record or Collection models events without doing manual type assertion, you can use the equivalent `OnRecord*` and `OnCollection*` proxy hooks.**

```go
package main

import (
    "log"

    "github.com/pocketbase/pocketbase"
    "github.com/pocketbase/pocketbase/core"
)

func main() {
    app := pocketbase.New()

    // fires for every model
    app.OnModelAfterDeleteError().BindFunc(func(e *core.ModelErrorEvent) error {
        // e.App
        // e.Model
        // e.Error

        return e.Next()
    })

    // fires only for "users" and "articles" models
    app.OnModelAfterDeleteError("users", "articles").BindFunc(func(e *core.ModelErrorEvent) error {
        // e.App
        // e.Model
        // e.Error

        return e.Next()
    })

    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

For a complete list of available hooks and their event objects, please refer to the [PocketBase Go documentation](https://pkg.go.dev/github.com/pocketbase/pocketbase).
