这是一个非常明智的**降维打击**策略。

在引入不确定性的 AI 之前，先构建一个**确定性的、高效率的**命令系统，这符合 "Gall's Law"（所有复杂的系统都是从简单的系统演化而来的）。

如果这个 TUI 在没有 AI 的情况下就已经是一个让 Geek 爱不释手的工具（类似 `fzf` 或 `vim` 的手感），那么后续加上 AI 只是锦上添花；反之，如果基础交互很烂，加了 AI 也救不回来。

以下是 **Phase 1: Deterministic PocketBase TUI** 的设计规范与实现路径。

---

# [SPEC] PocketBase TUI (Phase 1: The Foundation)

## 1. 核心交互隐喻 (Interaction Metaphor)

我们将整个 TUI 的交互核心收敛到底部的 **Omni-Bar (全能输入框)**。

* **`/` (Slash Commands):** **动作 (Verbs)**。
* 定义“我要做什么”。
* 例如：`/list`, `/view`, `/create`, `/delete`, `/logs`.


* **`@` (Resource Selectors):** **对象 (Nouns)**。
* 定义“我要操作谁”。
* 例如：`@col:users`, `@log:error`, `@record:ID`.


* **`Space` (Parameters):** **参数**。
* 例如：`filter="status='active'"`。



**Geek Flow:**
用户键入 `/v` (Tab补全 `/view`) -> 空格 -> `@u` (Tab补全 `@users`) -> Enter。
界面立即跳转到 Users 集合的表格视图。

---

## 2. 架构设计 (React + Ink)

### 2.1 目录结构

```text
src/
  ├── components/
  │   ├── OmniBar/         # 核心组件：处理 / 和 @ 的逻辑
  │   ├── DataGrid/        # 通用表格视图 (Ink Table)
  │   └── LogStream/       # 日志视图
  ├── stores/
  │   └── appState.ts      # UI 状态 (CurrentView, SelectedResource)
  ├── lib/
  │   ├── pb.ts            # PocketBase SDK 单例
  │   └── registry.ts      # 命令与资源注册表
  └── app.tsx              # 路由分发

```

### 2.2 状态机 (State Machine)

我们需要一个简单的状态机来管理界面路由：

* **GLOBAL:** `OmniBar` 始终聚焦 (或通过快捷键唤起)。
* **VIEW_MODE:**
* `DASHBOARD`: 概览
* `COLLECTION_LIST`: 所有集合
* `RECORD_LIST`: 某个集合的具体数据 (依赖 `@collection`)
* `LOGS`: 实时日志



---

## 3. 核心实现：The Omni-Bar (代码原型)

这是 Phase 1 最难也最关键的部分。我们需要实现一个输入框，它能**感知**你输入了 `/` 或 `@`，并弹出相应的自动补全菜单。

我们需要用到 `ink-text-input` 和 `ink-select-input`。

```tsx
// src/components/OmniBar/index.tsx
import React, { useState, useEffect } from 'react';
import { Box, Text } from 'ink';
import TextInput from 'ink-text-input';
import SelectInput from 'ink-select-input';
import { pb } from '../../lib/pb';

// 1. 定义命令注册表 (Static)
const COMMANDS = [
    { label: '/view (View Records)', value: '/view' },
    { label: '/cols (List Collections)', value: '/cols' },
    { label: '/logs (Stream Logs)', value: '/logs' },
    { label: '/quit (Exit)', value: '/quit' },
];

export const OmniBar = ({ onSubmit }: { onSubmit: (cmd: string) => void }) => {
    const [query, setQuery] = useState('');
    const [suggestions, setSuggestions] = useState<any[]>([]);
    const [mode, setMode] = useState<'command' | 'resource' | 'input'>('input');

    // 2. 监听输入，触发补全模式
    const handleChange = async (val: string) => {
        setQuery(val);

        // 检测 Slash 命令
        if (val.startsWith('/') && !val.includes(' ')) {
            setMode('command');
            setSuggestions(COMMANDS.filter(c => c.value.startsWith(val)));
            return;
        }

        // 检测 @ 资源引用 (获取最后一个单词)
        const lastWord = val.split(' ').pop() || '';
        if (lastWord.startsWith('@')) {
            setMode('resource');
            // 实时从 PB Fetch Collections
            try {
                const cols = await pb.collections.getFullList();
                const items = cols.map(c => ({
                    label: `@${c.name} (${c.type})`,
                    value: `@${c.name}`
                }));
                setSuggestions(items.filter(i => i.value.startsWith(lastWord)));
            } catch (e) {
                setSuggestions([]);
            }
            return;
        }

        setMode('input');
        setSuggestions([]);
    };

    // 3. 处理补全选中
    const handleSelect = (item: any) => {
        if (mode === 'command') {
            setQuery(item.value + ' '); // 补全命令并加空格
            setMode('input'); // 切回输入模式等待参数
        } else if (mode === 'resource') {
            // 替换最后一个正在输入的 @xxx
            const words = query.split(' ');
            words.pop();
            setQuery(words.join(' ') + ' ' + item.value + ' ');
            setMode('input');
        }
    };

    return (
        <Box flexDirection="column" borderStyle="round" borderColor="cyan">
            {/* 4. 悬浮补全菜单 (类似于 VSCode 的 Intellisense) */}
            {suggestions.length > 0 && (
                <Box borderStyle="single" borderColor="grey" marginBottom={1}>
                    <SelectInput 
                        items={suggestions} 
                        onSelect={handleSelect} 
                        limit={5}
                    />
                </Box>
            )}
            
            <Box>
                <Text color="green">➜ </Text>
                <TextInput 
                    value={query} 
                    onChange={handleChange} 
                    onSubmit={onSubmit}
                    placeholder="Type / to act, @ to select..."
                />
            </Box>
        </Box>
    );
};

```

---

## 4. 路由与执行逻辑 (The Executor)

当用户在 `OmniBar` 按下 Enter 后，我们需要解析字符串并切换视图。

```tsx
// src/app.tsx
import React, { useState } from 'react';
import { Box, Text } from 'ink';
import { OmniBar } from './components/OmniBar';
import { RecordTable } from './components/DataGrid'; // 假设你有这个组件

export default function App() {
    const [view, setView] = useState('dashboard');
    const [targetCollection, setTargetCollection] = useState('');
    const [logs, setLogs] = useState([]);

    const handleCommand = (input: string) => {
        const parts = input.trim().split(/\s+/);
        const cmd = parts[0];
        const arg = parts[1]; // 通常是 @collection

        switch (cmd) {
            case '/cols':
                setView('collection_list');
                break;
            case '/view':
                if (arg && arg.startsWith('@')) {
                    setTargetCollection(arg.substring(1)); // 去掉 @
                    setView('record_list');
                } else {
                    // Show Error: "Please specify a collection using @"
                }
                break;
            case '/logs':
                setView('logs');
                break;
            case '/quit':
                process.exit(0);
        }
    };

    return (
        <Box flexDirection="column" height={20}>
            {/* Main Content Area */}
            <Box flexGrow={1} borderStyle="single">
                {view === 'dashboard' && <Text>Welcome to PocketBase TUI</Text>}
                
                {view === 'record_list' && (
                    <RecordTable collection={targetCollection} />
                )}
                
                {view === 'logs' && <Text>Streaming logs... (Todo)</Text>}
            </Box>

            {/* OmniBar Area */}
            <OmniBar onSubmit={handleCommand} />
        </Box>
    );
}

```

---

## 5. Phase 1 交付标准 (MVP)

要达到“好用”的标准，Phase 1 必须完成以下三个核心场景的闭环：

1. **快速浏览:**
* 键入 `/cols` -> Enter -> 看到所有表。
* 键入 `/view @users` -> Enter -> 看到用户列表。


2. **简单查询:**
* 在浏览 `users` 时，OmniBar 支持 filter 参数。
* 输入: `/view @users email~'gmail'` -> 表格仅显示 Gmail 用户。


3. **日志监控:**
* 键入 `/logs` -> 界面切换到即时滚动的日志流（利用 JS SDK 的 `pb.realtime`）。



## 6. 为什么这为 AI 铺平了道路？

这步棋走得非常妙，原因如下：

1. **Context 结构化:** 当你通过 `@users` 这种显式的方式选择资源时，我们在代码内部其实已经把 `users` 的 Schema 获取到了。未来接 AI 时，我们只需要把这个已经获取到的 Schema 喂给 LLM 即可。
2. **Action 确定化:** `/view`, `/create` 这些命令定义了系统的**能力边界 (Capabilities)**。未来这些命令就是 MCP 的 Tool Definition。
3. **用户习惯培养:** 你正在训练用户（和你自己）习惯这种 "Command + Context" 的操作模式。当 Phase 2 引入 AI 时，用户只是把“手动输入命令”变成了“用自然语言描述命令”，心智模型是平滑过渡的。

**Next Action:**
你需要先把 React + Ink 的环境搭起来，并调通 `OmniBar` 中 `@` 触发 SDK 获取 Collection 列表的逻辑。这是最爽的一个功能点。