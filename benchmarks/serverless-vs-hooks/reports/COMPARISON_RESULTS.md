# Serverless (QuickJS) vs JSVM (Goja) 性能对比报告

**测试环境**:
- OS: macOS (darwin)
- CPU: Apple M1 Pro (10 cores)
- Arch: arm64
- Go: 1.24.0
- 测试时间: 2026-01-10

## 测试结果对比

### 1. 简单函数调用 (Hello World)

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **251** | 192 | 7 | 1x |
| QuickJS | 21,555 | 69,468 | 27 | **86x 慢** |

**结论**: Goja 在简单调用上快 **86 倍**。

### 2. 计算密集型 (斐波那契 n=15)

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| Goja | 218,192 | 3,392 | 8 | 1.1x 慢 |
| **QuickJS** | **194,822** | 228,725 | 28 | **1x** |

**结论**: QuickJS 在计算密集型任务上快 **12%**。

### 3. JSON 解析

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **6,334** | 5,096 | 144 | **1x** |
| QuickJS | 11,205 | 47,685 | 23 | 1.8x 慢 |

**结论**: Goja JSON 解析快 **77%**。

### 4. JSON 序列化

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **2,385** | 1,667 | 44 | **1x** |
| QuickJS | 33,562 | 69,615 | 24 | 14x 慢 |

**结论**: Goja JSON 序列化快 **14 倍**。

### 5. 数组 Map 操作 (100 元素)

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **~8,000** | ~10,000 | ~200 | **1x** |
| QuickJS | ~40,000 | ~50,000 | ~25 | 5x 慢 |

**结论**: Goja 数组操作快约 **5 倍**。

### 6. 正则表达式

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **~800** | 160 | 4 | **1x** |
| QuickJS | ~20,000 | ~48,000 | ~23 | 25x 慢 |

**结论**: Goja 正则匹配快 **25 倍**。

### 7. VM 创建开销

| 场景 | Goja (ns) | QuickJS (ns) | 比率 |
|------|-----------|--------------|------|
| 仅创建 | **5,500** | 15,000 | 2.7x |
| 创建+执行 | **120,000** | 35,000 | 0.3x |

**结论**: Goja VM 创建更快，但 QuickJS 创建+执行更快（因为模拟模式）。

### 8. 并发性能

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 |
|--------|-------------|-------------|----------|
| **Goja (Pool)** | **~2,700** | ~1,900 | ~200 |
| QuickJS (Pool) | ~3,300 | ~48,000 | ~23 |

**结论**: Goja 并发性能略优，但两者都可接受。

### 9. HTTP Handler 模拟

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **~4,500** | ~4,800 | ~97 | **1x** |
| QuickJS | ~35,000 | ~70,000 | ~25 | 8x 慢 |

**结论**: Goja HTTP Handler 处理快 **8 倍**。

### 10. 数据验证

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **~3,200** | ~4,100 | ~49 | **1x** |
| QuickJS | ~20,000 | ~48,000 | ~23 | 6x 慢 |

**结论**: Goja 数据验证快 **6 倍**。

### 11. 异常处理

| 场景 | Goja (ns) | QuickJS (ns) | 比率 |
|------|-----------|--------------|------|
| 无异常 | **~150** | ~18,500 | 123x |
| 有异常 | **~640** | ~18,500 | 29x |

**结论**: Goja 异常处理快 **29-123 倍**。

### 12. 字符串拼接 (100 次)

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **~37,000** | 44,417 | 702 | **1x** |
| QuickJS | ~63,000 | 47,264 | 26 | 1.7x 慢 |

**结论**: Goja 字符串操作快 **70%**。

### 13. 闭包调用

| 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 | 比率 |
|--------|-------------|-------------|----------|------|
| **Goja** | **~181** | 200 | 3 | **1x** |
| QuickJS | ~16,700 | ~48,000 | 23 | 92x 慢 |

**结论**: Goja 闭包调用快 **92 倍**。

## 综合对比汇总

| 场景 | 胜出者 | 性能差距 |
|------|--------|----------|
| 简单函数调用 | **Goja** | 86x |
| 计算密集型 | **QuickJS** | 1.12x |
| JSON 解析 | **Goja** | 1.8x |
| JSON 序列化 | **Goja** | 14x |
| 数组操作 | **Goja** | 5x |
| 正则表达式 | **Goja** | 25x |
| VM 创建 | **Goja** | 2.7x |
| 并发性能 | **Goja** | 1.2x |
| HTTP Handler | **Goja** | 8x |
| 数据验证 | **Goja** | 6x |
| 异常处理 | **Goja** | 29-123x |
| 字符串操作 | **Goja** | 1.7x |
| 闭包调用 | **Goja** | 92x |

**总计**: Goja 胜出 **12/13** 场景，QuickJS 仅在计算密集型场景胜出。

## 关键发现

### 1. Goja (JSVM) 优势
- **启动极快**: VM 创建仅 5.5μs
- **函数调用高效**: 约 250ns/调用
- **JSON 处理优秀**: 解析 6μs，序列化 2.4μs
- **正则匹配极快**: 约 0.8μs
- **闭包高效**: 约 180ns
- **异常处理高效**: 无异常 150ns，有异常 640ns

### 2. QuickJS (Serverless) 优势
- **计算密集型更快**: 递归斐波那契快 12%
- **内存隔离**: WASM 沙箱提供安全隔离
- **资源限制**: 可限制 CPU 和内存使用
- **超时控制**: 原生支持执行超时

### 3. QuickJS 当前劣势（模拟模式）
- **启动开销大**: 每次执行需要解析代码
- **无状态**: 无法复用已编译的函数
- **内存开销**: 每次执行约 48-70KB

## 使用建议

### 推荐使用 Goja (JSVM)
✅ 简单的 Hook 逻辑（数据验证、字段转换）
✅ 低延迟要求的场景（API 处理）
✅ 可信代码执行（内部脚本）
✅ JSON 处理密集型任务
✅ 正则表达式匹配

### 推荐使用 QuickJS (Serverless)
✅ 不可信代码执行（用户提交的脚本）
✅ 需要内存/CPU 限制的场景
✅ 计算密集型任务（复杂算法）
✅ 需要严格隔离的多租户场景
✅ 长时间运行的任务（需要超时控制）

## 性能优化建议

### Goja 优化
1. 使用 `sync.Pool` 复用 VM 实例
2. 预编译常用脚本
3. 避免频繁创建新 VM

### QuickJS 优化
1. 实现真正的 WASM 编译（替换模拟模式）
2. 支持预编译字节码缓存
3. 实现 VM 实例池化

## 原始数据

- Goja 单独测试: `benchmark_results.txt`
- 对比测试: `comparison_results.txt`
