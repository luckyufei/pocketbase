# Serverless vs JSVM (Goja) 性能对比报告

**测试环境**:
- OS: macOS (darwin)
- CPU: Apple M1 Pro (10 cores)
- Go: 1.24.0
- 测试时间: 2026-01-10

## 测试结果汇总

### 1. 简单函数调用 (Hello World)

| 测试场景 | 运行时 | 耗时 (ns/op) | 内存 (B/op) | 分配次数 |
|---------|--------|-------------|-------------|----------|
| 单次调用 | Goja | ~244 | 192 | 7 |
| 池化调用 | Goja (sync.Pool) | ~146 | 232 | 9 |

**结论**: Goja 单次函数调用约 244ns，使用池化后可降至 146ns。

### 2. 计算密集型 (斐波那契)

| n 值 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| 10 | ~19.8ms | 1.6KB |
| 20 | ~2.46s | 3.7KB |
| 25 | ~26.9s | 6.5KB |
| 30 | ~289.6s | 38.3KB |

**结论**: 递归斐波那契在 JS 引擎中开销巨大，fib(30) 需要约 290ms。

### 3. JSON 处理

| 操作 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| JSON.parse | ~6.1μs | 5.1KB |
| JSON.stringify | ~2.3μs | 1.7KB |

**结论**: JSON 解析约 6μs，序列化约 2.3μs。

### 4. 字符串处理

| 操作 | 规模 | Goja 耗时 | 内存分配 |
|------|------|-----------|----------|
| 字符串拼接 | 100 | ~33μs | 44KB |
| 字符串拼接 | 1000 | ~1.8ms | 3.3MB |
| 字符串拼接 | 10000 | ~175ms | 322MB |
| 正则匹配 | - | ~0.8μs | 160B |

**结论**: 字符串拼接开销随规模线性增长，正则匹配非常高效。

### 5. 数组操作 (1000 元素)

| 操作 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| map | ~78μs | 98KB |
| filter | ~42μs | 50KB |
| reduce | ~35μs | 32KB |
| sort | ~1.2ms | 1.1MB |

**结论**: 数组操作性能良好，sort 开销最大。

### 6. 对象创建

| 规模 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| 100 对象 | ~36μs | 46KB |
| 1000 对象 | ~322μs | 427KB |

**结论**: 对象创建约 360ns/对象。

### 7. 闭包调用

| 操作 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| 闭包调用 | ~54ns | 8B |

**结论**: 闭包调用非常高效。

### 8. 异常处理

| 场景 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| 无异常 | ~150ns | 56B |
| 有异常 | ~2.7μs | 1.1KB |

**结论**: 异常处理开销约为正常执行的 18 倍。

### 9. VM 创建开销

| 场景 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| 仅创建 | ~5.5μs | 62KB |
| 创建+简单执行 | ~120μs | 114KB |
| 创建+复杂执行 | ~143μs | 116KB |

**结论**: VM 创建约 5.5μs，加载代码后约 120μs。

### 10. 并发性能

| 并发数 | Goja 耗时 (ns/op) | 内存分配 |
|--------|-------------------|----------|
| 1 | ~2.6μs | 1.9KB |
| 10 | ~2.8μs | 1.9KB |
| 50 | ~2.8μs | 1.9KB |
| 100 | ~2.8μs | 1.9KB |

**结论**: 使用 sync.Pool 后并发扩展性良好。

### 11. 内存分配

| 分配大小 | Goja 耗时 | 内存分配 |
|----------|-----------|----------|
| 1MB | ~41ms | 25.6MB |
| 5MB | ~197ms | 123.7MB |
| 10MB | ~395ms | 242.9MB |

**结论**: 大内存分配开销显著，1MB 约 41ms。

### 12. 真实场景模拟

| 场景 | Goja 耗时 | 内存分配 |
|------|-----------|----------|
| HTTP Handler | ~4.6μs | 4.8KB |
| 数据转换 (100条) | ~219μs | 162KB |
| 数据验证 | ~3.2μs | 4.1KB |

**结论**: 真实场景下性能表现良好。

## 关键发现

### Goja (JSVM) 优势
1. **启动快**: VM 创建约 5.5μs
2. **简单调用高效**: 函数调用约 244ns
3. **正则高效**: 约 0.8μs
4. **闭包高效**: 约 54ns

### Goja (JSVM) 劣势
1. **计算密集型慢**: 递归算法开销大
2. **大内存分配慢**: 1MB 需要 41ms
3. **字符串拼接慢**: 大量拼接开销线性增长
4. **非线程安全**: 需要池化管理

## 与 QuickJS (Serverless) 对比预期

基于架构分析：

| 特性 | Goja | QuickJS (WASM) |
|------|------|----------------|
| 启动时间 | ~5.5μs | ~1-10ms (WASM 加载) |
| 简单调用 | ~244ns | ~1-5μs (WASM 开销) |
| 计算密集型 | 中等 | 更快 (原生编译) |
| 内存隔离 | 无 | 有 (WASM 沙箱) |
| 超时控制 | 需手动实现 | 原生支持 |
| 线程安全 | 否 | 是 (独立实例) |

## 使用建议

### 推荐使用 Goja (JSVM)
- 简单的 Hook 逻辑
- 低延迟要求的场景
- 可信代码执行

### 推荐使用 QuickJS (Serverless)
- 不可信代码执行
- 需要内存/CPU 限制
- 计算密集型任务
- 需要严格隔离的场景

## 原始数据

详见 `benchmark_results.txt`
